<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Fleet Dashboard</title>

<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<style>
body {
    margin:0;
    font-family: Arial, sans-serif;
    background:#f4f6f9;
}

/* HEADER */
header {
    background:#1f2937;
    color:white;
    padding:12px 20px;
    font-size:18px;
    font-weight:bold;
}

/* CONTROL PANEL */
.controls {
    background:white;
    padding:12px;
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    align-items:center;
    box-shadow:0 2px 8px rgba(0,0,0,0.1);
}

.controls select, .controls button {
    padding:6px;
    border-radius:6px;
    border:1px solid #ccc;
}

.controls button {
    background:#2563eb;
    color:white;
    border:none;
    cursor:pointer;
}

.controls button:hover {
    background:#1d4ed8;
}

/* MAP */
#map {
    height: calc(100vh - 120px);
    width:100%;
}

/* MOBILE */
@media(max-width:768px){
    .controls {
        flex-direction:column;
        align-items:stretch;
    }

    #map {
        height: calc(100vh - 180px);
    }
}
</style>
</head>
<body>

<header>Fleet Monitoring Dashboard</header>

<div class="controls">
    <select id="modeSelect">
        <option value="single">Single Bus</option>
        <option value="all">All Buses</option>
    </select>

    <select id="busSelect"></select>

    <select id="dateSelect"></select>

    <button onclick="loadRoute()">Load</button>
</div>

<div id="map"></div>

<script>

let map = L.map('map').setView([20,78],5);
let initialZoomDone = false;

let layers = [];
let selectedStops = [];
let currentRouteData = [];
let busLabelMap = {};

const osm = L.tileLayer(
'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
{ attribution:'¬© OpenStreetMap' }
).addTo(map);

const satellite = L.tileLayer(
'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
{ attribution:'¬© Esri' }
);

L.control.layers({"Street":osm,"Satellite":satellite}).addTo(map);

function clearMap(){
    layers.forEach(l=>map.removeLayer(l));
    layers=[];
    selectedStops=[];
}

function createBusIcon(color){
    return L.divIcon({
        html: `<div style="
            width:40px;
            height:20px;
            background:${color};
            mask:url('/static/bus.svg') no-repeat center;
            -webkit-mask:url('/static/bus.svg') no-repeat center;
            mask-size:contain;
            -webkit-mask-size:contain;
        "></div>`,
        className:'',
        iconSize:[40,20],
        iconAnchor:[20,10]
    });
}

async function loadBuses(){

    let buses = await fetch('/buses').then(r=>r.json());

    let busSelect = document.getElementById('busSelect');

    busSelect.innerHTML='';

    busLabelMap = {};   // reset

    buses.forEach(b=>{

        busLabelMap[b.id] = b.label;   // ‚≠ê THIS WAS MISSING

        let opt=document.createElement('option');

        opt.value=b.id;

        opt.textContent=b.label;

        busSelect.appendChild(opt);

    });

}


    async function loadDates(){

    let bus=document.getElementById('busSelect').value;

    if(!bus) return;

    let dates=await fetch(`/dates/${bus}`).then(r=>r.json());

    let dateSelect=document.getElementById('dateSelect');
    dateSelect.innerHTML='';

    if(!dates || dates.length===0){
        let opt=document.createElement('option');
        opt.value="";
        opt.textContent="No Journeys Found";
        dateSelect.appendChild(opt);
        return;
    }

    dates.forEach(d=>{
        let [y,m,day]=d.split("-");
        let formatted=`${day}-${m}-${y}`;

        let opt=document.createElement('option');
        opt.value=d;
        opt.textContent=formatted;
        dateSelect.appendChild(opt);
    });
}


document.getElementById('busSelect')
.addEventListener('change', async ()=>{
    await loadDates();
    focusOnBus();
});

document.getElementById('modeSelect')
.addEventListener('change', async function(){

    let mode=this.value;

    if(mode==='all'){
        document.getElementById('busSelect').style.display='none';
        await loadAllDates();
    } else {
        document.getElementById('busSelect').style.display='inline-block';
        await loadDates();
    }
});

function formatTimestamp(ts){
    let date = new Date(ts * 1000);
    let day = String(date.getDate()).padStart(2,'0');
    let month = String(date.getMonth()+1).padStart(2,'0');
    let year = date.getFullYear();
    let hours = String(date.getHours()).padStart(2,'0');
    let minutes = String(date.getMinutes()).padStart(2,'0');

    return `${day}-${month}-${year} ${hours}:${minutes}`;
}



async function focusOnBus(){
    let bus=document.getElementById('busSelect').value;
    let date=document.getElementById('dateSelect').value;

    if(!date) return;

    let data=await fetch(`/route/${bus}/${date}`).then(r=>r.json());

    if(data.length>0){
        let last=data[data.length-1];
        map.setView([last[0],last[1]],13);
    }
}

async function loadAllDates(){
    let dates = await fetch('/all-dates').then(r=>r.json());
    let dateSelect = document.getElementById('dateSelect');
    dateSelect.innerHTML='';

    dates.forEach(d=>{
        let [y,m,day]=d.split("-");
        let formatted=`${day}-${m}-${y}`;

        let opt=document.createElement('option');
        opt.value=d;
        opt.textContent=formatted;
        dateSelect.appendChild(opt);
    });
}


function makeSelectable(marker, point){

    marker.on('click', function(e){

        e.originalEvent.stopPropagation();

        let index = selectedStops.indexOf(point);

        if(index !== -1){

            // deselect
            selectedStops.splice(index,1);

            if(marker.setStyle){

                marker.setStyle({
                    color: marker.options.originalColor || marker.options.color,
                    weight:1
                });

            }

        } else {

            // select

            selectedStops.push(point);

            if(marker.setStyle){

                marker.setStyle({
                    color:"black",
                    weight:3
                });

            }

        }

        if(selectedStops.length === 2){

            measure();

        }

    });

}


async function loadRoute(){

    clearMap();

    let mode=document.getElementById('modeSelect').value;

    if(mode==='all'){
        loadAllBuses();
        return;
    }

    let bus=document.getElementById('busSelect').value;
    let date=document.getElementById('dateSelect').value;

    let data = await fetch(`/route/${bus}/${date}`).then(r=>r.json());

    if(!data || data.length===0) return;

    let coords = data.map(r=>[r[0],r[1]]);
    let color = randomColor();

    // ================= ROUTE LINE =================
    let line=L.polyline(coords,{
        color:color,
        weight:4
    }).addTo(map);

    layers.push(line);

    // ================= üü¢ START POINT =================
    let start=L.circleMarker(coords[0],{
        radius:7,
        color:"green",
        fillColor:"green",
        fillOpacity:1
    })
    .bindPopup(
        `<b>Journey Start</b><br>
        Time: ${formatTimestamp(data[0][2])}`
    )
    .addTo(map);

    makeSelectable(start, data[0]);  // üëà selectable
    layers.push(start);

    // ================= BUS MARKER =================
    let totalDistance=calculateTotalDistance(data);
    let totalTime=calculateTotalTime(data);

    let busMarker=L.marker(coords[coords.length-1],
        {icon:createBusIcon(color)}
    ).bindTooltip(
        `<b>${busLabelMap[bus] || bus}</b><br>
        Distance: ${totalDistance} km<br>
        Time: ${totalTime}`
    ).addTo(map);

    layers.push(busMarker);

    // ================= üü† TEMPORARY STOP DETECTION =================
    let stopStartTime = null;

    for(let i=0;i<data.length;i++){

        let point = data[i];
        let speed = point[3]; // requires backend speed

        // consider <=3 km/h as halted (GPS noise safe)
        if(speed !== undefined && speed <= 3){

            if(stopStartTime === null){
                stopStartTime = point[2];
            }

            let stopDuration = point[2] - stopStartTime;

            // 2 minutes to <1 hour = temporary stop
            if(stopDuration >= 120 && stopDuration < 3600){

                let stop=L.circleMarker(
                    [point[0],point[1]],
                    {
                        radius:7,
                        color:"orange",
                        fillColor:"orange",
                        fillOpacity:1
                    }
                )
                .bindPopup(
                    `<b>Temporary Stop</b><br>
                    Time: ${formatTimestamp(point[2])}<br>
                    Duration: ${Math.floor(stopDuration/60)} min`
                )
                .addTo(map);

                makeSelectable(stop, point);   // üëà selectable
                layers.push(stop);

                stopStartTime = null; // prevent duplicates
            }

        } else {
            stopStartTime = null;
        }
    }

    // ================= üî¥ JOURNEY END (if ended in backend) =================
    // Detect if last 1 hour has no movement (frontend fallback display)

// ================= üî¥ JOURNEY END (Correct Logic) =================

let idleStartTime = null;
let lastIdlePoint = null;

for(let i=0;i<data.length;i++){

    let point = data[i];
    let speed = point[3];

    if(speed !== undefined && speed <= 3){

        if(idleStartTime === null){
            idleStartTime = point[2];
            lastIdlePoint = point;
        }

        let idleDuration = point[2] - idleStartTime;

        if(idleDuration >= 3600){

            let end=L.circleMarker(
                [point[0],point[1]],
                {
                    radius:8,
                    color:"red",
                    fillColor:"red",
                    fillOpacity:1
                }
            )
            .bindPopup(
                `<b>Journey End</b><br>
                 Time: ${formatTimestamp(point[2])}<br>
                 Idle: ${Math.floor(idleDuration/60)} min`
            )
            .addTo(map);

            makeSelectable(end, point);
            layers.push(end);

            break; // Only mark first valid end
        }

    } else {
        idleStartTime = null;
        lastIdlePoint = null;
    }
}

    // ================= FIT MAP =================
    map.fitBounds(line.getBounds());
}

function isStop(index,data){
    if(index===0) return false;
    return (data[index][2]-data[index-1][2])>=120;
}



async function measure(){
    let bus=document.getElementById('busSelect').value;
    let date=document.getElementById('dateSelect').value;

    let result=await fetch('/measure',{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({
            bus_no:bus,
            trip_date:date,
            start_ts:selectedStops[0][2],
            end_ts:selectedStops[1][2]
        })
    }).then(r=>r.json());

    alert(`Distance: ${result.distance_km} km\nTime: ${result.hours}h ${result.minutes}m`);

    selectedStops=[];
}

function calculateTotalDistance(data){
    let d=0;
    for(let i=1;i<data.length;i++){
        d+=haversine(data[i-1][0],data[i-1][1],data[i][0],data[i][1]);
    }
    return d.toFixed(2);
}

function calculateTotalTime(data){
    let diff=data[data.length-1][2]-data[0][2];
    let h=Math.floor(diff/3600);
    let m=Math.floor((diff%3600)/60);
    return `${h}h ${m}m`;
}

function haversine(lat1, lon1, lat2, lon2){
    const R=6371;
    const dLat=(lat2-lat1)*Math.PI/180;
    const dLon=(lon2-lon1)*Math.PI/180;
    const a=Math.sin(dLat/2)**2+
        Math.cos(lat1*Math.PI/180)*
        Math.cos(lat2*Math.PI/180)*
        Math.sin(dLon/2)**2;
    return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
}

function randomColor(){
    return '#'+Math.floor(Math.random()*16777215).toString(16);
}

async function loadAllBuses(){

    clearMap();

    let date=document.getElementById('dateSelect').value;

    if(!date) return;

    let buses=await fetch('/buses').then(r=>r.json());

    for(let b of buses){

        let bus = b.id;  // ‚≠ê FIX

        let data=await fetch(`/route/${bus}/${date}`).then(r=>r.json());

        if(!data || data.length===0) continue;

        let coords=data.map(r=>[r[0],r[1]]);

        let color=randomColor();

        let line=L.polyline(coords,{color:color}).addTo(map);

        layers.push(line);

        let marker=L.marker(coords[coords.length-1],
            {icon:createBusIcon(color)}
        )
        .bindTooltip(busLabelMap[bus] || bus)  // ‚≠ê FIX
        .addTo(map);

        layers.push(marker);

    }

}

loadBuses().then(loadDates);


</script>
</body>
</html>
