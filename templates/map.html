
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Fleet Dashboard</title>

<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<style>
body {
    margin:0;
    font-family: Arial, sans-serif;
    background:#f4f6f9;
}

/* HEADER */
header {
    background:#1f2937;
    color:white;
    padding:12px 20px;
    font-size:18px;
    font-weight:bold;
}

/* CONTROL PANEL */
.controls {
    background:white;
    padding:12px;
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    align-items:center;
    box-shadow:0 2px 8px rgba(0,0,0,0.1);
}

.controls select, .controls button {
    padding:6px;
    border-radius:6px;
    border:1px solid #ccc;
}

.controls button {
    background:#2563eb;
    color:white;
    border:none;
    cursor:pointer;
}

.controls button:hover {
    background:#1d4ed8;
}

/* MAP */
#map {
    height: calc(100vh - 120px);
    width:100%;
}

/* MOBILE */
@media(max-width:768px){
    .controls {
        flex-direction:column;
        align-items:stretch;
    }

    #map {
        height: calc(100vh - 180px);
    }
}
</style>
</head>
<body>

<header>Fleet Monitoring Dashboard</header>

<div class="controls">
    <select id="modeSelect">
        <option value="single">Single Bus</option>
        <option value="all">All Buses</option>
    </select>

    <select id="busSelect"></select>

    <select id="dateSelect"></select>

    <button onclick="loadRoute()">Load</button>
</div>

<div id="map"></div>

<script>

let map = L.map('map').setView([20,78],5);
let initialZoomDone = false;

let layers = [];
let selectedStops = [];
let currentRouteData = [];
let busLabelMap = {};

const osm = L.tileLayer(
'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
{ attribution:'© OpenStreetMap' }
).addTo(map);

const satellite = L.tileLayer(
'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
{ attribution:'© Esri' }
);

L.control.layers({"Street":osm,"Satellite":satellite}).addTo(map);

function clearMap(){
    layers.forEach(l=>map.removeLayer(l));
    layers=[];
    selectedStops=[];
}

function createBusIcon(color){
    return L.divIcon({
        html: `<div style="
            width:40px;
            height:20px;
            background:${color};
            mask:url('/static/bus.svg') no-repeat center;
            -webkit-mask:url('/static/bus.svg') no-repeat center;
            mask-size:contain;
            -webkit-mask-size:contain;
        "></div>`,
        className:'',
        iconSize:[40,20],
        iconAnchor:[20,10]
    });
}

async function loadBuses(){

    let buses = await fetch('/buses').then(r=>r.json());

    let busSelect = document.getElementById('busSelect');

    busSelect.innerHTML='';

    busLabelMap = {};   // reset

    buses.forEach(b=>{

        busLabelMap[b.id] = b.label;   // ⭐ THIS WAS MISSING

        let opt=document.createElement('option');

        opt.value=b.id;

        opt.textContent=b.label;

        busSelect.appendChild(opt);

    });

}


    async function loadDates(){

    let bus=document.getElementById('busSelect').value;

    if(!bus) return;

    let dates=await fetch(`/dates/${bus}`).then(r=>r.json());

    let dateSelect=document.getElementById('dateSelect');
    dateSelect.innerHTML='';

    if(!dates || dates.length===0){
        let opt=document.createElement('option');
        opt.value="";
        opt.textContent="No Journeys Found";
        dateSelect.appendChild(opt);
        return;
    }

    dates.forEach(d=>{
        let [y,m,day]=d.split("-");
        let formatted=`${day}-${m}-${y}`;

        let opt=document.createElement('option');
        opt.value=d;
        opt.textContent=formatted;
        dateSelect.appendChild(opt);
    });
}


document.getElementById('busSelect')
.addEventListener('change', async ()=>{
    await loadDates();
    focusOnBus();
});

document.getElementById('modeSelect')
.addEventListener('change', async function(){

    let mode=this.value;

    if(mode==='all'){
        document.getElementById('busSelect').style.display='none';
        await loadAllDates();
    } else {
        document.getElementById('busSelect').style.display='inline-block';
        await loadDates();
    }
});

function formatTimestamp(ts){
    let date = new Date(ts * 1000);
    let day = String(date.getDate()).padStart(2,'0');
    let month = String(date.getMonth()+1).padStart(2,'0');
    let year = date.getFullYear();
    let hours = String(date.getHours()).padStart(2,'0');
    let minutes = String(date.getMinutes()).padStart(2,'0');

    return `${day}-${month}-${year} ${hours}:${minutes}`;
}



async function focusOnBus(){
    let bus=document.getElementById('busSelect').value;
    let date=document.getElementById('dateSelect').value;

    if(!date) return;

    let data=await fetch(`/route/${bus}/${date}`).then(r=>r.json());

    if(data.length>0){
        let last=data[data.length-1];
        map.setView([last[0],last[1]],13);
    }
}

async function loadAllDates(){
    let dates = await fetch('/all-dates').then(r=>r.json());
    let dateSelect = document.getElementById('dateSelect');
    dateSelect.innerHTML='';

    dates.forEach(d=>{
        let [y,m,day]=d.split("-");
        let formatted=`${day}-${m}-${y}`;

        let opt=document.createElement('option');
        opt.value=d;
        opt.textContent=formatted;
        dateSelect.appendChild(opt);
    });
}


function makeSelectable(marker, point){

    marker.on('click', function(e){

        e.originalEvent.stopPropagation();

        let index = selectedStops.indexOf(point);

        if(index !== -1){

            // deselect
            selectedStops.splice(index,1);

            if(marker.setStyle){

                marker.setStyle({
                    color: marker.options.originalColor || marker.options.color,
                    weight:1
                });

            }

        } else {

            // select

            selectedStops.push(point);

            if(marker.setStyle){

                marker.setStyle({
                    color:"black",
                    weight:3
                });

            }

        }

        if(selectedStops.length === 2){

            measure();

        }

    });

}
// ⭐ OSRM MATCH FUNCTION WITH CHUNKIN
async function getMatchedRoute(raw){

    const CHUNK_SIZE = 100;

    // ⭐ STEP 1: REMOVE DUPLICATES & VERY CLOSE POINTS
    let filtered = [];

    for(let i=0;i<raw.length;i++){

        if(i===0){
            filtered.push(raw[i]);
            continue;
        }

        let prev = filtered[filtered.length-1];

        let dist = haversine(
            prev[0], prev[1],
            raw[i][0], raw[i][1]
        );

        // keep only if > 5 meters
        if(dist > 0.005){

            filtered.push(raw[i]);

        }

    }

    let finalCoords = [];

    let totalDistance = 0;

    // ⭐ STEP 2: SEND IN CHUNKS
    for(let i=0;i<filtered.length;i+=CHUNK_SIZE){

        let chunk = filtered.slice(i,i+CHUNK_SIZE);

        if(chunk.length < 2) continue;

        let coords = chunk.map(
            p => `${p[1]},${p[0]}`
        ).join(";");

        try{

            let response = await fetch(
            `https://router.project-osrm.org/match/v1/driving/${coords}?overview=full&geometries=geojson`
            );

            if(!response.ok) continue;

            let osrm = await response.json();

            if(osrm.matchings){

                let part = osrm.matchings[0].geometry.coordinates.map(
                    p => [p[1], p[0]]
                );

                finalCoords.push(...part);

                totalDistance += osrm.matchings[0].distance;

            }

        }
        catch(e){

            console.log("OSRM skipped chunk");

        }

    }

    return {

        coords: finalCoords,

        distanceKm: (totalDistance/1000).toFixed(2)

    };

}



async function loadRoute(){

    clearMap();

    let mode=document.getElementById('modeSelect').value;

    if(mode==='all'){
        loadAllBuses();
        return;
    }

    let bus=document.getElementById('busSelect').value;
    let date=document.getElementById('dateSelect').value;

    // RAW DATA
    let raw = await fetch(`/route/${bus}/${date}`).then(r=>r.json());

    if(!raw || raw.length===0) return;

    // GET MATCHED ROUTE
    let result = await getMatchedRoute(raw);

    let matchedCoords = result.coords;

    let totalDistance = result.distanceKm;

    if(!matchedCoords || matchedCoords.length===0) return;

    let totalTime = calculateTotalTime(raw);

    let color = randomColor();

    // ROUTE LINE
    let line=L.polyline(matchedCoords,{
        color:color,
        weight:4
    }).addTo(map);

    layers.push(line);

    // START MARKER
    let start=L.circleMarker(matchedCoords[0],{
        radius:7,
        color:"green",
        fillColor:"green",
        fillOpacity:1
    })
    .bindPopup(
        `<b>Journey Start</b><br>
        Time: ${formatTimestamp(raw[0][2])}`
    )
    .addTo(map);

    layers.push(start);

    // BUS MARKER
    let busMarker=L.marker(
        matchedCoords[matchedCoords.length-1],
        {icon:createBusIcon(color)}
    )
    .bindTooltip(
        `<b>${busLabelMap[bus] || bus}</b><br>
        Distance: ${totalDistance} km<br>
        Time: ${totalTime}`
    )
    .addTo(map);

    layers.push(busMarker);

    map.fitBounds(line.getBounds());

}


function isStop(index,data){
    if(index===0) return false;
    return (data[index][2]-data[index-1][2])>=120;
}



async function measure(){
    let bus=document.getElementById('busSelect').value;
    let date=document.getElementById('dateSelect').value;

    let result=await fetch('/measure',{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({
            bus_no:bus,
            trip_date:date,
            start_ts:selectedStops[0][2],
            end_ts:selectedStops[1][2]
        })
    }).then(r=>r.json());

    alert(`Distance: ${result.distance_km} km\nTime: ${result.hours}h ${result.minutes}m`);

    selectedStops=[];
}

function calculateTotalDistance(data){
    let d=0;
    for(let i=1;i<data.length;i++){
        d+=haversine(data[i-1][0],data[i-1][1],data[i][0],data[i][1]);
    }
    return d.toFixed(2);
}

function calculateTotalTime(data){
    let diff=data[data.length-1][2]-data[0][2];
    let h=Math.floor(diff/3600);
    let m=Math.floor((diff%3600)/60);
    return `${h}h ${m}m`;
}

function haversine(lat1, lon1, lat2, lon2){
    const R=6371;
    const dLat=(lat2-lat1)*Math.PI/180;
    const dLon=(lon2-lon1)*Math.PI/180;
    const a=Math.sin(dLat/2)**2+
        Math.cos(lat1*Math.PI/180)*
        Math.cos(lat2*Math.PI/180)*
        Math.sin(dLon/2)**2;
    return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
}

function randomColor(){
    return '#'+Math.floor(Math.random()*16777215).toString(16);
}

async function loadAllBuses(){

    clearMap();

    let date=document.getElementById('dateSelect').value;

    if(!date) return;

    let buses=await fetch('/buses').then(r=>r.json());

    for(let b of buses){

        let bus = b.id;  // ⭐ FIX

        let data=await fetch(`/route/${bus}/${date}`).then(r=>r.json());

        if(!data || data.length===0) continue;

        let coords=data.map(r=>[r[0],r[1]]);

        let color=randomColor();

        let line=L.polyline(coords,{color:color}).addTo(map);

        layers.push(line);

        let marker=L.marker(coords[coords.length-1],
            {icon:createBusIcon(color)}
        )
        .bindTooltip(busLabelMap[bus] || bus)  // ⭐ FIX
        .addTo(map);

        layers.push(marker);

    }

}

loadBuses().then(loadDates);


</script>
</body>
</html>
